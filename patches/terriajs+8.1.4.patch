diff --git a/node_modules/terriajs/lib/Models/SearchProviders/CatalogSearchProvider.ts b/node_modules/terriajs/lib/Models/SearchProviders/CatalogSearchProvider.ts
index da2317f..2125827 100644
--- a/node_modules/terriajs/lib/Models/SearchProviders/CatalogSearchProvider.ts
+++ b/node_modules/terriajs/lib/Models/SearchProviders/CatalogSearchProvider.ts
@@ -16,6 +16,8 @@ interface CatalogSearchProviderOptions {
   terria: Terria;
 }
 
+// import saveModelToJson from "../Definition/saveModelToJson"
+
 type UniqueIdString = string;
 type ResultMap = Map<UniqueIdString, boolean>;
 export function loadAndSearchCatalogRecursively(
@@ -23,7 +25,9 @@ export function loadAndSearchCatalogRecursively(
   searchTextLowercase: string,
   searchResults: SearchProviderResults,
   resultMap: ResultMap,
-  iteration: number = 0
+  iteration: number = 0,
+  // added to allow Search By Type and Search By Day
+  searchBy: string = "default"
 ): Promise<void> {
   // checkTerriaAgainstResults(terria, searchResults)
   // don't go further than 10 deep, but also if we have references that never
@@ -31,32 +35,57 @@ export function loadAndSearchCatalogRecursively(
   if (iteration > 10) {
     return Promise.resolve();
   }
+
   // add some public interface for terria's `models`?
   const referencesAndGroupsToLoad: any[] = models.filter((model: any) => {
+    
     if (resultMap.get(model.uniqueId) === undefined) {
       const modelToSave = model.target || model;
       // Use a flattened string of definition data later,
       // without only checking name/id/descriptions?
       // saveModelToJson(modelToSave, {
-      //   includeStrata: [CommonStrata.definition]
-      // });
-      autorun(reaction => {
-        const searchString = `${modelToSave.name} ${modelToSave.uniqueId} ${modelToSave.description}`;
-        const matchesString =
-          searchString.toLowerCase().indexOf(searchTextLowercase) !== -1;
-        resultMap.set(model.uniqueId, matchesString);
-        if (matchesString) {
-          runInAction(() => {
-            searchResults.results.push(
-              new SearchResult({
-                name: name,
-                catalogItem: modelToSave
-              })
-            );
-          });
-        }
-        reaction.dispose();
-      });
+        //   includeStrata: [CommonStrata.definition]
+        // });
+        
+        // const modelToSaveJson = saveModelToJson(modelToSave);
+        autorun(reaction => {
+          // const searchString = `${modelToSave.name} ${modelToSave.uniqueId} ${modelToSave.description}`;
+          let searchString = "";
+          
+          switch(searchBy) {
+            case "date": {
+              searchString = `${modelToSave.info[0]?.content}`;
+              break;
+            }
+            case "event": {
+              searchString = `${modelToSave.info[1]?.content}`;
+              break;
+            }
+            case "grid": {
+              searchString = `${modelToSave.info[2]?.content}`;
+              break;
+            }
+            default: {
+              searchString = `${modelToSave.name} ${modelToSave.uniqueId} ${modelToSave.description}`;
+              break;
+            }
+          }
+
+          const matchesString =
+            searchString.toLowerCase().indexOf(searchTextLowercase) !== -1;
+          resultMap.set(model.uniqueId, matchesString);
+          if (matchesString) {
+            runInAction(() => {
+              searchResults.results.push(
+                new SearchResult({
+                  name: modelToSave.name,
+                  catalogItem: modelToSave
+                })
+              );
+            });
+          }
+          reaction.dispose();
+        });
     }
 
     if (ReferenceMixin.isMixedInto(model) || GroupMixin.isMixedInto(model)) {
@@ -93,7 +122,8 @@ export function loadAndSearchCatalogRecursively(
             searchTextLowercase,
             searchResults,
             resultMap,
-            iteration + 1
+            iteration + 1,
+            searchBy
           )
         );
       });
@@ -120,7 +150,8 @@ export default class CatalogSearchProvider extends SearchProvider {
 
   protected async doSearch(
     searchText: string,
-    searchResults: SearchProviderResults
+    searchResults: SearchProviderResults,
+    searchBy?: string
   ): Promise<void> {
     this.isSearching = true;
     searchResults.results.length = 0;
@@ -143,11 +174,14 @@ export default class CatalogSearchProvider extends SearchProvider {
         const results = await this.terria.catalogIndex?.search(searchText);
         runInAction(() => (searchResults.results = results));
       } else {
+        let defaultIteration = 0;
         await loadAndSearchCatalogRecursively(
           this.terria.modelValues,
           searchText.toLowerCase(),
           searchResults,
-          resultMap
+          resultMap,
+          defaultIteration,
+          searchBy
         );
       }
 
diff --git a/node_modules/terriajs/lib/Models/SearchProviders/SearchProvider.ts b/node_modules/terriajs/lib/Models/SearchProviders/SearchProvider.ts
index 6e88323..87d8cb1 100644
--- a/node_modules/terriajs/lib/Models/SearchProviders/SearchProvider.ts
+++ b/node_modules/terriajs/lib/Models/SearchProviders/SearchProvider.ts
@@ -17,16 +17,17 @@ export default abstract class SearchProvider {
   }
 
   @action
-  search(searchText: string): SearchProviderResults {
+  search(searchText: string, searchBy?: string): SearchProviderResults {
     const result = new SearchProviderResults(this);
     result.resultsCompletePromise = fromPromise(
-      this.doSearch(searchText, result)
+      this.doSearch(searchText, result, searchBy)
     );
     return result;
   }
 
   protected abstract doSearch(
     searchText: string,
-    results: SearchProviderResults
+    results: SearchProviderResults,
+    searchBy?: string
   ): Promise<void>;
 }
diff --git a/node_modules/terriajs/lib/ReactViewModels/SearchState.ts b/node_modules/terriajs/lib/ReactViewModels/SearchState.ts
index 909e486..d921534 100644
--- a/node_modules/terriajs/lib/ReactViewModels/SearchState.ts
+++ b/node_modules/terriajs/lib/ReactViewModels/SearchState.ts
@@ -100,16 +100,36 @@ export default class SearchState {
     ]);
   }
 
+  // @action
+  // searchCatalog() {
+  //   if (this.isWaitingToStartCatalogSearch) {
+  //     this.isWaitingToStartCatalogSearch = false;
+  //     if (this.catalogSearchResults) {
+  //       this.catalogSearchResults.isCanceled = true;
+  //     }
+  //     if (this.catalogSearchProvider) {
+  //       this.catalogSearchResults = this.catalogSearchProvider.search(
+  //         this.catalogSearchText
+  //       );
+  //     }
+  //   }
+  // }
+
   @action
-  searchCatalog() {
+  searchCatalog(searchBy?: string) {
+    // if searchBy is undefined set it to default
+    searchBy = searchBy !== undefined ? searchBy : "default";
     if (this.isWaitingToStartCatalogSearch) {
       this.isWaitingToStartCatalogSearch = false;
       if (this.catalogSearchResults) {
         this.catalogSearchResults.isCanceled = true;
       }
+      console.log("SearchState.searchCatalog", this.catalogSearchProvider);
       if (this.catalogSearchProvider) {
+        // this is causing the error right now. search can't be called directly from catalogSearchProvider
         this.catalogSearchResults = this.catalogSearchProvider.search(
-          this.catalogSearchText
+          this.catalogSearchText,
+          searchBy
         );
       }
     }
